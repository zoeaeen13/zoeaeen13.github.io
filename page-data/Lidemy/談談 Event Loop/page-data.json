{"componentChunkName":"component---src-templates-blog-post-js","path":"/Lidemy/談談 Event Loop/","result":{"data":{"site":{"siteMetadata":{"title":"Travel in Time.","author":"Zoe Yu"}},"markdownRemark":{"id":"fa54378e-544e-5bfb-87c9-2c1eb35add0e","excerpt":"本篇將透過解釋 Event Loop 機制，理解以下常見的名詞及 JS 執行特性 Call Stack 執行堆疊 JS 是一個單執行緒的語言，有一個單執行緒的 Runtime（執行環境系統），執行緒可以想像成執行工作的單位，單執行緒意味著它一次只能做一件事。在程式碼運行前，JS…","html":"<p>本篇將透過解釋 Event Loop 機制，理解以下常見的名詞及 JS 執行特性</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">Single Thread 單執行緒\nCall stack 呼叫堆疊\nBlocking 阻塞\nEvent loop 事件循環\nCallback 回調\nCallback Queue 回調序列</code></pre></div>\n<hr>\n<h2 id=\"Call-Stack-執行堆疊\" style=\"position:relative;\">Call Stack 執行堆疊<a href=\"#Call-Stack-%E5%9F%B7%E8%A1%8C%E5%A0%86%E7%96%8A\" aria-label=\"Call Stack 執行堆疊 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>JS 是一個單執行緒的語言，有一個單執行緒的 Runtime（執行環境系統），執行緒可以想像成執行工作的單位，單執行緒意味著它一次只能做一件事。在程式碼運行前，JS 的 Runtime（記憶體堆疊、默認執行環境、執行環境堆疊）會被建立。</p>\n<p>之後依序執行，一旦呼叫到其他函式，Global EC 會幫呼叫到的函式產生新的 Execution Context 放到 stack 上，當多個函式被呼叫就會產生多個 EC，依序堆疊上去，這被稱為執行堆疊（call stack）。</p>\n<p>call stack 的特性是後進先出，最後被堆上去的 EC 會作為目前的執行環境先被執行，因為單執行緒的特性，一次只會執行一個程式碼片段，要等到該函式執行完畢 reurn 後，它的 EC 才會自動從執行堆疊的頂端抽掉（pop off），再執行底下一層的程式碼。</p>\n<p><img src=\"https://i.imgur.com/t0xDDE2.png\"></p>\n<blockquote>\n<p><strong>為什麼不能在一個函式呼叫它自己？</strong></p>\n</blockquote>\n<p>無窮迴圈，會造成堆疊爆炸（Stack Overflow）</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"Blocking-阻塞\" style=\"position:relative;\">Blocking 阻塞<a href=\"#Blocking-%E9%98%BB%E5%A1%9E\" aria-label=\"Blocking 阻塞 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>然而，有些東西就是跑特別慢，需要等待很長一段時間，比如網路請求、圖片請求、或純粹就是執行過程漫長的程式碼，當這些跑得慢的東西又處在目前的堆疊上，就會造成「Blocking（堵塞）」。</p>\n<p>如果現在是同步設定，那麼一旦發生 blocking，畫面就會壞掉、好像「卡住」的現象，這是因為瀏覽器被塞住、無法繼續渲染頁面，變成我們什麼事都做不了，而面對這種狀況，我們就需要「非同步回調（Async Callback）」機制。</p>\n<p>簡單來說，就是在需要跑比較久的程式碼中用上非同步方法（Asynchronous），裡面塞一個 callback function（簡稱 cb），這樣就會先執行一段程式碼，然後過段時間再回調裡面的 cb，不會立即執行到而造成阻塞。</p>\n<h2 id=\"Concurrency-並行機制\" style=\"position:relative;\">Concurrency 並行機制<a href=\"#Concurrency-%E4%B8%A6%E8%A1%8C%E6%A9%9F%E5%88%B6\" aria-label=\"Concurrency 並行機制 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>那肯定就會好奇，callback function 是怎麼做到會等待一段時間再執行？為什麼它能等到結束做、能監測什麼時候要結束等待？JavaScript Runtime 不是一件只能做一件事嗎？</p>\n<p>沒錯，JavaScript 的確是單執行緒，它在執行一段程式碼的時候，就不能同時紀錄 setTimeout 的要求、做 HTTP Request 網路請求，而讓這一切實現的關鍵並不是 JavaScript，而是<strong>瀏覽器</strong>。\n瀏覽器額外提供了很多東西，類似各種不同的執行緒，一些你只能經由呼叫、無法取得的執行緒，比如 setTimeout 就是其中一個，它是環境所提供，並非來自 JS Runtime 本身。</p>\n<p>當你在 Call Stack 執行這行去呼叫它後，瀏覽器就會為你啟動一個計時器，然後 JS 繼續執行下一行，而 <code class=\"language-text\">setTimeout()</code> 實際上是出現在瀏覽器另外提供的執行緒中進行計時，其他像 AJAX、Fetch、DOM 也都是瀏覽器提供的 API。</p>\n<p><img src=\"https://i.imgur.com/TVo3hwu.png\"></p>\n<h2 id=\"Event-Loop-和-Callback-Queue\" style=\"position:relative;\">Event Loop 和 Callback Queue<a href=\"#Event-Loop-%E5%92%8C-Callback-Queue\" aria-label=\"Event Loop 和 Callback Queue permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>那 <code class=\"language-text\">setTimeout()</code> 執行完畢後，裡面的 cb 該怎麼處理？剛剛說到會「回調」，那是丟回堆疊中直接執行嗎？</p>\n<p>當然不可能如此簡單粗暴，瀏覽器不會傻呼呼直接丟回堆疊上，這樣根本無法控制它出現的時機，Web APIs 會在執行完 <code class=\"language-text\">setTimeout()</code> 之後將它的 callback function 放到一個名為 Callback Queue 的地方，所有非同步執行的程式碼會被推到這裡等待執行。</p>\n<p>而安排 Callback Queue 裡面的任務去到堆疊，是由「Event Loop（事件循環）」負責，你可以想像它就是在辦公大樓上班的警衛，尖峰時端擠滿一堆要上樓的上班族，而大家滑著手機、都在排隊等待電梯，電梯很小，一次只能容納一個人，就是這位警衛來幫他們觀察電梯什麼時候空出來，一旦電梯抵達一樓，就通知排隊的第一個人可以上班了。</p>\n<p><strong>Event Loop 決定事件的執行順序</strong>，它不斷監控 stack 和 queue 的狀態，查到堆疊的狀態是空的，就換檢查 Callback Queue 中有沒有準備好的 cb，就把最前面的 cb 抓起來送到堆疊上執行，所以可以說 JavaScript 可以並行的基礎是因為 Event Loop 的存在。</p>\n<p><img src=\"https://i.imgur.com/PBYJawC.png\"></p>\n<h2 id=\"更進一步：認識瀏覽器的運行環境\" style=\"position:relative;\">更進一步：認識瀏覽器的運行環境<a href=\"#%E6%9B%B4%E9%80%B2%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%80%8F%E8%A6%BD%E5%99%A8%E7%9A%84%E9%81%8B%E8%A1%8C%E7%92%B0%E5%A2%83\" aria-label=\"更進一步：認識瀏覽器的運行環境 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>從上面我們知道了在 JS Runtime 之外，瀏覽器還提供了 Web APIs、Queue、Event Loop 等等東西來幫助任務執行，整個瀏覽器的運作環境，包含 JS 引擎，我們稱為 JS Runtime Environment（JRE）</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20190928/20106580oVudusuOwX.jpg\"></p>\n<blockquote>\n<p><strong>Q: 零延遲（Zero delays）是什麼？</strong></p>\n</blockquote>\n<p>有時候我們會看到將 setTimeout 設成零，這麼做並非表示 callback function 會在 0 毫秒之後立刻執行，從上面 Event Loop 的運作我們了解到：這個 cb 會等待堆疊清空後才被執行到。</p>\n<p>呼叫 setTimeout 的使用，不代表過了那段時間就會執行，時間參數只是要求處理的最少等待時間，我們還得考慮到在 Queue 中等待的訊息數量，setTimeout 是讓我們把任務推遲到堆疊的最後再執行。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'this is the start'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'this is a msg from call back'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'this is just a message'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">cb1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'this is a msg from call back1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'this is the end'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// \"this is the start\"</span>\n<span class=\"token comment\">// \"this is just a message\"</span>\n<span class=\"token comment\">// \"this is the end\"</span>\n<span class=\"token comment\">// \"this is a msg from call back\"</span>\n<span class=\"token comment\">// \"this is a msg from call back1\"</span></code></pre></div>\n<blockquote>\n<p><strong>Q: 為什麼說不要做事件阻塞？</strong></p>\n</blockquote>\n<p>意思是，讓你別在堆疊上放慢到不行的程式碼，這樣會影響瀏覽器最重要的東西 ─ 畫面！</p>\n<p>一般來說，瀏覽器會在每 16.6 毫秒（也就是每秒 60 個幀）重新渲染一次畫面，但當堆疊上有程式碼的時候，瀏覽器就不能顯示東西，造成卡住。比如 <code class=\"language-text\">forEach()</code> 裡面的函式就不會做非同步，而是在當前的堆疊中執行，當你對每個元素做緩慢處理的同步迴圈，就會讓瀏覽器的顯示一直被擋住。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Synchronous</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">i</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>而當你知道<strong>渲染任務的優先權高於 callback function</strong>，你就應該重新思考程式碼的架構，像是將它改為回調函式，當他們同樣都在 Queue 中等待時，瀏覽器就可以自己找到機會安插渲染任務，順利保持流暢的 UI。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Asynchronous</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">asyncForEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">array<span class=\"token punctuation\">,</span> cb</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  array<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>cb<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"Q-為什麼-JavaScript-會是單執行緒的程式語言？\" style=\"position:relative;\">Q: 為什麼 JavaScript 會是單執行緒的程式語言？<a href=\"#Q-%E7%82%BA%E4%BB%80%E9%BA%BC-JavaScript-%E6%9C%83%E6%98%AF%E5%96%AE%E5%9F%B7%E8%A1%8C%E7%B7%92%E7%9A%84%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%EF%BC%9F\" aria-label=\"Q 為什麼 JavaScript 會是單執行緒的程式語言？ permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>為什麼 JavaScript 只能跑在一個 thread 上，一次只做一件事？</p>\n</blockquote>\n<p>與他的用途有關，當初 JavaScript 是為了在瀏覽器上運作，與使用者互動以及操作DOM而設計的，這決定了他只能是單執行緒，否則會帶來很複雜的同步問題。比如同時有兩個執行緒存取到同一個 DOM 節點：</p>\n<ul>\n<li>一個執行緒在某個 DOM 節點上新增內容</li>\n<li>另一個執行緒刪除了這個節點</li>\n</ul>\n<p>瀏覽器要以哪個為主？為了避免這種麻煩才這樣設計，之前寫過 Android 開發，也發現會要求任何跟 UI 有關的操作都得在主執行緒進行，就是為了避免無法預料的狀況。</p>\n<h2 id=\"小結\" style=\"position:relative;\">小結<a href=\"#%E5%B0%8F%E7%B5%90\" aria-label=\"小結 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>堆疊當下的程式碼會執行完畢，過程中不會被 async code 中斷</li>\n<li>就算 setTimeout() 延遲時間設定為 0，程式也不會立即執行到，依然會被排在 Callback Queue 等待堆疊清空</li>\n<li>JavaScript 只能跑單執行緒，但瀏覽器像是提供了它運作多執行緒的可能，利用 Event Loop 機制去幫助 JavaScript 執行任務</li>\n<li>瀏覽器中，渲染畫面的優先權高於 callback function</li>\n</ul>\n<h2 id=\"參考資料\" style=\"position:relative;\">參考資料<a href=\"#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\" aria-label=\"參考資料 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li><a href=\"hhttps://milletbard.com/2019/11/25/JavaScript-event-loop/\">Javascript [筆記] 理解 Event Loop,Call Stack, Event &#x26; Job Queue in Javascript</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/EventLoop\">並行模型和事件循環</a></li>\n<li><a href=\"https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html\">[筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式</a></li>\n<li><a href=\"https://yakimhsu.com/project/project_w16_EventLoop.html\">[第十六週] JavaScript 進階：事件迴圈 Event Loop、Stack、Queue</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10214017\">Day5 [JavaScript 基礎] Event Loop 機制</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10221944\">JS 原力覺醒 Day13 - Event Queue &#x26; Event Loop 、Event Table</a></li>\n</ul>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","tableOfContents":"<ul>\n<li><a href=\"/Lidemy/%E8%AB%87%E8%AB%87%20Event%20Loop/#call-stack-%E5%9F%B7%E8%A1%8C%E5%A0%86%E7%96%8A\">Call Stack 執行堆疊</a></li>\n<li><a href=\"/Lidemy/%E8%AB%87%E8%AB%87%20Event%20Loop/#blocking-%E9%98%BB%E5%A1%9E\">Blocking 阻塞</a></li>\n<li><a href=\"/Lidemy/%E8%AB%87%E8%AB%87%20Event%20Loop/#concurrency-%E4%B8%A6%E8%A1%8C%E6%A9%9F%E5%88%B6\">Concurrency 並行機制</a></li>\n<li><a href=\"/Lidemy/%E8%AB%87%E8%AB%87%20Event%20Loop/#event-loop-%E5%92%8C-callback-queue\">Event Loop 和 Callback Queue</a></li>\n<li><a href=\"/Lidemy/%E8%AB%87%E8%AB%87%20Event%20Loop/#%E6%9B%B4%E9%80%B2%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%80%8F%E8%A6%BD%E5%99%A8%E7%9A%84%E9%81%8B%E8%A1%8C%E7%92%B0%E5%A2%83\">更進一步：認識瀏覽器的運行環境</a></li>\n<li><a href=\"/Lidemy/%E8%AB%87%E8%AB%87%20Event%20Loop/#q-%E7%82%BA%E4%BB%80%E9%BA%BC-javascript-%E6%9C%83%E6%98%AF%E5%96%AE%E5%9F%B7%E8%A1%8C%E7%B7%92%E7%9A%84%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%EF%BC%9F\">Q: 為什麼 JavaScript 會是單執行緒的程式語言？</a></li>\n<li><a href=\"/Lidemy/%E8%AB%87%E8%AB%87%20Event%20Loop/#%E5%B0%8F%E7%B5%90\">小結</a></li>\n<li><a href=\"/Lidemy/%E8%AB%87%E8%AB%87%20Event%20Loop/#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\">參考資料</a></li>\n</ul>","frontmatter":{"title":"談談 Event Loop","date":"Nov 12, 2020","tags":["JavaScript","Lidemy","Event Loop"],"category":"程式導師計畫","thumbnail":null}}},"pageContext":{"slug":"/Lidemy/談談 Event Loop/","previous":{"fields":{"slug":"/Lidemy/什麼是 Single Page Application/"},"frontmatter":{"title":"什麼是 Single Page Application","tags":["JavaScript","Lidemy"],"date":"2020-10-11","category":"程式導師計畫","mark":null,"description":"了解 SPA 架構及其優缺點"}},"next":{"fields":{"slug":"/Lidemy/在用之前，先了解為什麼要學 React/"},"frontmatter":{"title":"為什麼要學 React？","tags":["React","Lidemy"],"date":"2020-11-29","category":"程式導師計畫","mark":null,"description":"談談 React 的核心，元件化及單向資料流"}}}},"staticQueryHashes":["63159454"]}