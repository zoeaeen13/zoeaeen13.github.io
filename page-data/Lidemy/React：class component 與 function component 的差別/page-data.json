{"componentChunkName":"component---src-templates-blog-post-js","path":"/Lidemy/React：class component 與 function component 的差別/","result":{"data":{"site":{"siteMetadata":{"title":"Travel in Time.","author":"Zoe Yu"}},"markdownRemark":{"id":"2d7fe217-ec1e-5b59-9885-c923b2e25604","excerpt":"在 hook 出來以前，其實就有 class component 和 function component 兩種寫法，不過當時只有前者可以擁有 state 和 lifecycle，function component 只用來單純呈現資料，內容寫死或是透過 props…","html":"<p>在 hook 出來以前，其實就有 class component 和 function component 兩種寫法，不過當時只有前者可以擁有 state 和 lifecycle，function component 只用來單純呈現資料，內容寫死或是透過 props 傳入。</p>\n<p>但是，<strong>hook 的出現改變了一切</strong>，解決了 function component 不能擁有 state 的問題，也變相讓它擁有類似生命週期方法的操作。<a href=\"../React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks\">前面</a>已經分別介紹過生命週期和 hook，以下就他們的差別：</p>\n<h3 id=\"1-兩者在渲染上的差別\" style=\"position:relative;\">1. 兩者在渲染上的差別<a href=\"#1-%E5%85%A9%E8%80%85%E5%9C%A8%E6%B8%B2%E6%9F%93%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%A5\" aria-label=\"1 兩者在渲染上的差別 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>function component 就是一個單純回傳 JSX 的函式，而 class component 是一個繼承 <code class=\"language-text\">React.Component</code> 的 JS 物件，它裡面必須調用一個 <code class=\"language-text\">render()</code> 方法，這個方法會回傳 JSX。</p>\n<h3 id=\"2-props-傳遞\" style=\"position:relative;\">2. props 傳遞<a href=\"#2-props-%E5%82%B3%E9%81%9E\" aria-label=\"2 props 傳遞 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk13\">&lt;</span><span class=\"mtk4\">Component</span><span class=\"mtk1\"> </span><span class=\"mtk8\">name</span><span class=\"mtk1\">=</span><span class=\"mtk11\">&quot;Molly&quot;</span><span class=\"mtk1\"> </span><span class=\"mtk13\">/&gt;</span></span></span></code></pre>\n<ul>\n<li>在 function component 是作為引數 props 傳入</li>\n<li>在 class component 因為是物件，呼叫 <code class=\"language-text\">constructor()</code> 來建構並初始化，使用 this 來引用</li>\n</ul>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// function component</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> FunctionComponent = ({ name }) </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> </span><span class=\"mtk13\">&lt;</span><span class=\"mtk4\">h1</span><span class=\"mtk13\">&gt;</span><span class=\"mtk1\">Hello, </span><span class=\"mtk4\">{</span><span class=\"mtk1\">name</span><span class=\"mtk4\">}</span><span class=\"mtk13\">&lt;/</span><span class=\"mtk4\">h1</span><span class=\"mtk13\">&gt;</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// class component</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> ClassComponent </span><span class=\"mtk4\">extends</span><span class=\"mtk1\"> React.Component {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">constructor</span><span class=\"mtk1\">(props) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">super</span><span class=\"mtk1\">(props);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  render() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> { name } = </span><span class=\"mtk4\">this</span><span class=\"mtk1\">.props;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> </span><span class=\"mtk13\">&lt;</span><span class=\"mtk4\">h1</span><span class=\"mtk13\">&gt;</span><span class=\"mtk1\">Hello, </span><span class=\"mtk4\">{</span><span class=\"mtk1\"> name </span><span class=\"mtk4\">}</span><span class=\"mtk13\">&lt;/</span><span class=\"mtk4\">h1</span><span class=\"mtk13\">&gt;</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h3 id=\"3-如何處理-state\" style=\"position:relative;\">3. 如何處理 state<a href=\"#3-%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86-state\" aria-label=\"3 如何處理 state permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>在以前 funciton component 是沒有狀態的，直到 <code class=\"language-text\">useState</code> 這個 hook 出現解決了這個問題，我們得以寫成 <strong>stateful</strong> function component。</p>\n<p>參考 <a href=\"https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e\">React hooks: not magic, just arrays</a>，以 hook API 將元件的行為/狀態和它本身連結起來，利用陣列去做狀態管理，當呼叫 <code class=\"language-text\">useState</code> 時，會傳入初始值，然後回傳一個陣列，陣列裡面分別是狀態的 value 和它的 setter function：</p>\n<ol>\n<li>初始化時，建立兩個空陣列 setters 和 state，設定指標為 0</li>\n<li>第一次渲染時，會將 setter function 和一個指標位置放到 setters 陣列，狀態放到 state 陣列</li>\n<li>每次更新渲染，指標就會重置，然後根據指標（cursor）去讀取陣列裡的值</li>\n<li>每一個 setter 都有一個指標位置，所以觸發 setter 的時候就會去變更陣列中對應 state 的值</li>\n</ol>\n<p>之所以「<strong>不能在條件式或迴圈調用 Hook</strong>」，正因為它是依賴 cursor 來取得陣列中的值，如果改變了順序那麼資料和 setter 就不對</p>\n<h3 id=\"4-優化效能提升\" style=\"position:relative;\">4. 優化效能提升<a href=\"#4-%E5%84%AA%E5%8C%96%E6%95%88%E8%83%BD%E6%8F%90%E5%8D%87\" aria-label=\"4 優化效能提升 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>class component：即使狀態沒變化，只要調用到 setstate 就會觸發重新渲染</li>\n<li>function component：會進行檢測，只有狀態值真正改變時，才會觸發渲染，換句話說就是提升了整體效能</li>\n</ul>\n<h3 id=\"5-生命週期方法的實現\" style=\"position:relative;\">5. 生命週期方法的實現<a href=\"#5-%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%A6%E7%8F%BE\" aria-label=\"5 生命週期方法的實現 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>不像 class component 是繼承 <code class=\"language-text\">React.Component</code>，function component 沒辦法擁有那些內建的生命週期方法，例如 <code class=\"language-text\">componentDidMount()</code> 來處理 side effect，我們會希望在更新 DOM 之後執行我們的 effect，像是網路請求資料、設定 subscription 和 event handler 或手動改變 DOM 等等。</p>\n<h5 id=\"-無需清除的-Effect\" style=\"position:relative;\">* 無需清除的 Effect<a href=\"#-%E7%84%A1%E9%9C%80%E6%B8%85%E9%99%A4%E7%9A%84-Effect\" aria-label=\" 無需清除的 Effect permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>在 React 更新 DOM 之後執行一些額外的程式碼。網路請求、手動變更 DOM、和 logging，直接執行，就不用再去記得它</p>\n<ul>\n<li>class component：將 side effect 放入 <code class=\"language-text\">componentDidMount()</code> 和 <code class=\"language-text\">componentDidUpdate()</code></li>\n</ul>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> Example </span><span class=\"mtk4\">extends</span><span class=\"mtk1\"> React.Component {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">constructor</span><span class=\"mtk1\">(props) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">super</span><span class=\"mtk1\">(props);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">this</span><span class=\"mtk1\">.state = {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      count: </span><span class=\"mtk5\">0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    };</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 因為希望在 mount 和 update 階段都會發生（每次 render 後），這裡得寫兩次</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  componentDidMount() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    document.title = </span><span class=\"mtk11\">`You clicked </span><span class=\"mtk4\">${this</span><span class=\"mtk1\">.state.count</span><span class=\"mtk4\">}</span><span class=\"mtk11\"> times`</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  componentDidUpdate() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    document.title = </span><span class=\"mtk11\">`You clicked </span><span class=\"mtk4\">${this</span><span class=\"mtk1\">.state.count</span><span class=\"mtk4\">}</span><span class=\"mtk11\"> times`</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  render() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<ul>\n<li>\n<p>funciton component\n在元件之內呼叫，透過使用這個 Hook，你告訴 React 你的元件需要在 render 後做一些事情。React 將記住你傳遞的 effect，並在執行 DOM 更新之後呼叫它。</p>\n<ul>\n<li>在 component 內部呼叫 useEffect，<strong>可直接存取到 state 和 props</strong>，因為它已經在 function 範圍內了，且 <strong>React 保證 DOM 在執行 effect 時已被更新</strong></li>\n<li>雖然預設 DOM 更新後呼叫，也可以透過 useEffect 第二個參數的設置來優化效能，規定比對條件才執行，而不是每次重新渲染就呼叫</li>\n<li>使用多個 Effect 來分離關注點</li>\n<li>想執行一個 effect 並且僅（在 mount 和 unmount 時）將其清除一次，則可以傳遞一個空 array（<code class=\"language-text\">[]</code>）作為第二個參數 => effect 不依賴於任何 props 或 state 的值，因此它不需要重新執行</li>\n</ul>\n</li>\n</ul>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">import</span><span class=\"mtk1\"> React, { useState, useEffect } </span><span class=\"mtk4\">from</span><span class=\"mtk1\"> </span><span class=\"mtk11\">&#39;react&#39;</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> Example() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> [count, setCount] = useState(</span><span class=\"mtk5\">0</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  useEffect(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    document.title = </span><span class=\"mtk11\">`You clicked </span><span class=\"mtk4\">${</span><span class=\"mtk1\">count</span><span class=\"mtk4\">}</span><span class=\"mtk11\"> times`</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  });</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> (</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<blockquote>\n<p><strong>Q: 每次 render 後都會執行 useEffect 嗎？</strong></p>\n</blockquote>\n<p>把 useEffect 視為 <code class=\"language-text\">componentDidMount</code>、<code class=\"language-text\">componentDidUpdate</code> 和 <code class=\"language-text\">componentWillUnmount</code> 的組合，與其把 useEffect 考慮在 mount 或 update 階段都執行，不如認為它是每次 render 後就執行。</p>\n<h5 id=\"-需要清除的-Effect\" style=\"position:relative;\">* 需要清除的 Effect<a href=\"#-%E9%9C%80%E8%A6%81%E6%B8%85%E9%99%A4%E7%9A%84-Effect\" aria-label=\" 需要清除的 Effect permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>有些設定對某些外部資料來源的 subscription，需要進行清除，以免造成 memory leak</p>\n<ul>\n<li>class component：寫在 componentWillUnmount 方法裡面，在元件移出畫面前清除</li>\n</ul>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">componentWillUnmount() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ChatAPI.unsubscribeFromFriendStatus(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk4\">this</span><span class=\"mtk1\">.props.friend.id,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk4\">this</span><span class=\"mtk1\">.handleStatusChange</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<ul>\n<li>function component：可選的清除機制</li>\n</ul>\n<p>每個 effect 都可以選擇是否回傳一個會在它之後執行清除的 function。我們可以把新增和移除 subscription 的邏輯保持靠近，因為它們都屬於同一個 effect！</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  useEffect(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> handleStatusChange(status) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      setIsOnline(status.isOnline);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// 指定如何在這個 effect 之後執行清除：</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> cleanup() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      ChatAPI.unsubscribeFromStatus(props.friend.id, handleStatusChange);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    };</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  });</span></span></span></code></pre>\n<blockquote>\n<p>2020/01/08：補充 @minw 助教的解答</p>\n</blockquote>\n<ul>\n<li>class component 是透過 ES6 Class 語法來實作基於 OOP 的元件</li>\n<li>function component 則是利用閉包來管理狀態</li>\n</ul>\n<p>前者由於 this 並非 immutable，導致 state、props 都會是最新的結果，對於一些 callback 操作的處理會比較複雜，例如：setTimeout；而後者則由於不需要使用 this、且保持 function 的特性讓<strong>共同邏輯更容易抽取出來共用</strong>，容易測試。</p>\n<p>當然，前者提供更多 lifecycle 方法讓比較複雜的元件狀態更好管理。</p>\n<hr>\n<h2 id=\"參考資料\" style=\"position:relative;\">參考資料<a href=\"#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\" aria-label=\"參考資料 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li><a href=\"https://zh-hant.reactjs.org/docs/react-component.html\">React.Component</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10214751\">Day 8】Class component &#x26;&#x26; Functional component</a></li>\n<li><a href=\"https://www.twilio.com/blog/react-choose-functional-components\">Understanding Functional Components vs. Class Components in React</a></li>\n<li><a href=\"https://andyyou.github.io/2019/07/29/hooks-not-magic-just-arrays/\">React Hooks 不是黑魔法，只是陣列</a></li>\n</ul>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .visual-studio-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .visual-studio-dark .mtk13 { color: #808080; }\n  .visual-studio-dark .mtk4 { color: #569CD6; }\n  .visual-studio-dark .mtk1 { color: #D4D4D4; }\n  .visual-studio-dark .mtk8 { color: #9CDCFE; }\n  .visual-studio-dark .mtk11 { color: #CE9178; }\n  .visual-studio-dark .mtk3 { color: #6A9955; }\n  .visual-studio-dark .mtk5 { color: #B5CEA8; }\n  .visual-studio-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","tableOfContents":"<ul>\n<li>\n<ul>\n<li><a href=\"/Lidemy/React%EF%BC%9Aclass%20component%20%E8%88%87%20function%20component%20%E7%9A%84%E5%B7%AE%E5%88%A5/#1-%E5%85%A9%E8%80%85%E5%9C%A8%E6%B8%B2%E6%9F%93%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%A5\">1. 兩者在渲染上的差別</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9Aclass%20component%20%E8%88%87%20function%20component%20%E7%9A%84%E5%B7%AE%E5%88%A5/#2-props-%E5%82%B3%E9%81%9E\">2. props 傳遞</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9Aclass%20component%20%E8%88%87%20function%20component%20%E7%9A%84%E5%B7%AE%E5%88%A5/#3-%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86-state\">3. 如何處理 state</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9Aclass%20component%20%E8%88%87%20function%20component%20%E7%9A%84%E5%B7%AE%E5%88%A5/#4-%E5%84%AA%E5%8C%96%E6%95%88%E8%83%BD%E6%8F%90%E5%8D%87\">4. 優化效能提升</a></li>\n<li>\n<p><a href=\"/Lidemy/React%EF%BC%9Aclass%20component%20%E8%88%87%20function%20component%20%E7%9A%84%E5%B7%AE%E5%88%A5/#5-%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%A6%E7%8F%BE\">5. 生命週期方法的實現</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/Lidemy/React%EF%BC%9Aclass%20component%20%E8%88%87%20function%20component%20%E7%9A%84%E5%B7%AE%E5%88%A5/#-%E7%84%A1%E9%9C%80%E6%B8%85%E9%99%A4%E7%9A%84-effect\">* 無需清除的 Effect</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9Aclass%20component%20%E8%88%87%20function%20component%20%E7%9A%84%E5%B7%AE%E5%88%A5/#-%E9%9C%80%E8%A6%81%E6%B8%85%E9%99%A4%E7%9A%84-effect\">* 需要清除的 Effect</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/Lidemy/React%EF%BC%9Aclass%20component%20%E8%88%87%20function%20component%20%E7%9A%84%E5%B7%AE%E5%88%A5/#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\">參考資料</a></li>\n</ul>","frontmatter":{"title":"React：Class component 與 Functional component 的差別","type":"coding","date":"Dec 10, 2020","tags":["React","Lidemy"],"category":"程式導師計畫","log":null,"thumbnail":null}}},"pageContext":{"slug":"/Lidemy/React：class component 與 function component 的差別/","previous":{"fields":{"slug":"/Lidemy/React：認識 Hooks/"},"frontmatter":{"title":"React：認識 Hooks","tags":["React","Lidemy"],"date":"2020-12-07","category":"程式導師計畫","mark":null,"description":"Hook 是一種重複使用邏輯的方法，讓 function component 可以擁有 state 的功能。","log":null}},"next":{"fields":{"slug":"/南松鶴上八仙下松鶴/"},"frontmatter":{"title":"山隊｜南松鶴上八仙下松鶴","tags":["政大山隊"],"date":"2021-01-08","category":"山裡的日子","mark":null,"description":null,"log":null}}}},"staticQueryHashes":["63159454"]}