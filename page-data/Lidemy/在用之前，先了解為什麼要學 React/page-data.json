{"componentChunkName":"component---src-templates-blog-post-js","path":"/Lidemy/在用之前，先了解為什麼要學 React/","result":{"data":{"site":{"siteMetadata":{"title":"Travel in Time.","author":"Zoe Yu"}},"markdownRemark":{"id":"f1f234d7-c941-567b-b34f-e6f4a9414c00","excerpt":"React 是 JavaScript 套件，而非一套框架，它在 MVC 架構中實際上是負責 View（介面）的部分，而要討論為什麼需要 React，就要從畫面談起。 傳統上，我們將 JS 和 HTML、CSS…","html":"<p>React 是 JavaScript 套件，而非一套框架，它在 MVC 架構中實際上是負責 View（介面）的部分，而要討論為什麼需要 React，就要從畫面談起。</p>\n<p>傳統上，我們將 JS 和 HTML、CSS 分離，其實這樣造成的問題有</p>\n<ol>\n<li>需要在多個檔案間來回切換</li>\n<li>維護性差，無法從單一檔案中了解結構，難以將 class 和行為連結</li>\n<li>畫面和資料想要保持一致，得自行做雙向狀態維護</li>\n</ol>\n<p>React 主要思維是「<strong>元件化</strong>」，它賦予我們用很簡便的方式建構一個新元件的能力，而這個元件在創造之時已經定義好了樣式，甚至可以透過傳遞參數（props）來改變自身的行為和樣式，達成邏輯和 UI 共存的目的。</p>\n<p><strong>要知道，顯示邏輯和模板中間，其實存在很強的關聯。</strong></p>\n<p>以前在 HTML 建立標籤，然後到 CSS 檔案添加不同狀態下的樣式，例如 TodoList 完成/未完成狀態顯示不同顏色的按鈕，然後到 JS 裡面真正實作它們之間的切換邏輯，不僅得自己操作 DOM、將把畫面和功能連結起來，還要寫狀態更新，一旦遇到大型的架構，更是難以維護。</p>\n<p>仔細想想，資料的狀態（state）對應某個樣式（UI），本來就是指同一件事，只是表達形式不一樣而已</p>\n<p><img src=\"https://i.imgur.com/W2Lr9e1.png\"></p>\n<p>以前因兩者分離，我們不得不自行寫邏輯將它們連結，一旦一方切換狀態、另一方就要更新，耗費大量心力來關注兩邊，當介面複雜時，容易出現資料和畫面不同步的 bug。</p>\n<hr>\n<p>選擇 React，正是因為它能夠幫我們解決這些問題</p>\n<h3 id=\"元件化的設計（Component-Based）\" style=\"position:relative;\">元件化的設計（Component-Based）<a href=\"#%E5%85%83%E4%BB%B6%E5%8C%96%E7%9A%84%E8%A8%AD%E8%A8%88%EF%BC%88Component-Based%EF%BC%89\" aria-label=\"元件化的設計（Component Based） permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>用簡單直觀的 JSX 語法自定義要呈現的 DOM 結構，通過接受不同的參數 props，來區分資料在哪些狀態下、介面應該分別長什麼樣子。</p>\n<p>不再需要手動操作 DOM，<strong>直接將資料和元件進行綁定，實現自動更新</strong>，讓畫面的一切由資料本身決定，一旦資料改變時就牽動 UI 變動，每當 React 偵測到 props 或 state 更新時，將自動重繪整個元件，不再需要分別維護資料和畫面的一致性，讓 UI 保持穩定，開發者只需要關注資料的狀態。</p>\n<p>當然還一些其他好處，比如具有 JavaScript 基礎就能快速上手、幫你實現跨平台或是性能好等優點，但這些都是次要，React 的核心設計就是 Component 元件化和 State 狀態管理。</p>\n<h3 id=\"優點\" style=\"position:relative;\">優點<a href=\"#%E5%84%AA%E9%BB%9E\" aria-label=\"優點 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>模組化、維護性佳，還可以重複利用的元件 Component</li>\n<li>JSX 跟 HTML 語法相似，方便描述 DOM 結構</li>\n<li>單向資料流，不會出現資料和畫面不一致的情況，因為任何改變全都由資料操作、自動渲染</li>\n<li>有 Virtual DOM 能最佳化複雜的 UI 效能</li>\n<li>React 寫 UI 就像組積木一樣，具有擴展性</li>\n</ul>\n<h3 id=\"缺點及限制\" style=\"position:relative;\">缺點及限制<a href=\"#%E7%BC%BA%E9%BB%9E%E5%8F%8A%E9%99%90%E5%88%B6\" aria-label=\"缺點及限制 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>學習門檻高，需要一定的時間來熟悉 React 各種用法和工具</li>\n<li>只處理 View/UI 的部分</li>\n<li>JSX 語法，寫起來像是在 JavaScript code 中夾雜 HTML</li>\n</ul>\n<p>整體來說，React 的出現賦予開發者創建、組織、變化的能力，元件化設計讓人更能思考整體架構，更直觀，聚焦在資料的變化，當然還有許多好用的框架/套件存在，可是如果一個專案會有「重複的 UI」、「時常變化的資料」等需求，其實就很適合使用 React。</p>\n<hr>\n<blockquote>\n<h3 id=\"React-的思考模式跟以前的思考模式有什麼不一樣？\" style=\"position:relative;\">React 的思考模式跟以前的思考模式有什麼不一樣？<a href=\"#React-%E7%9A%84%E6%80%9D%E8%80%83%E6%A8%A1%E5%BC%8F%E8%B7%9F%E4%BB%A5%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E9%BA%BC%E4%B8%8D%E4%B8%80%E6%A8%A3%EF%BC%9F\" aria-label=\"React 的思考模式跟以前的思考模式有什麼不一樣？ permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n</blockquote>\n<h3 id=\"一、基於元件化思考（Component）\" style=\"position:relative;\">一、基於元件化思考（Component）<a href=\"#%E4%B8%80%E3%80%81%E5%9F%BA%E6%96%BC%E5%85%83%E4%BB%B6%E5%8C%96%E6%80%9D%E8%80%83%EF%BC%88Component%EF%BC%89\" aria-label=\"一、基於元件化思考（Component） permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>React 中最基本的單元是元件（Component），每個元件又能包含一個以上的子元件，就像積木一樣，可以依照開發上的需求拼接，成為一個組合式的元件。理解 Component 具備的特性，才知道該怎麼思考：</p>\n<ul>\n<li>組合性（Compose） </li>\n</ul>\n<p>比如一個基本的表單有 <code class=\"language-text\">&lt;form&gt;</code>、<code class=\"language-text\">&lt;input&gt;</code>、<code class=\"language-text\">&lt;button&gt;</code> 等要素，可以將他們組合成為一個新元件，擁有自行創造、組織和變化的可能性</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// &lt;MailForm /></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>form</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>email<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>submit<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>form</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>另外，使用宣告式（Declarative）也讓程式碼更容易理解，很容易可以看出這個元件的功能</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">MailForm</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<ul>\n<li>封裝性（encapsulation）</li>\n</ul>\n<p>以前得將 HTML、CSS 和 JavaScript 分離，現在竟然能將邏輯和 UI 共用，不再適用傳統的模版思考（template）、不再需要模板語言。而 JSX 可以寫出類似 HTML 的語法，並透過 babel 將內容會轉化成 JavaScript 讓瀏覽器讀懂。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>App<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span>\n        <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span></span>\n      <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>複用性（Reuse）</li>\n</ul>\n<p>能夠最大化運用之前寫的程式碼，React 把 UI 切分為獨立並可重複使用的單位，並且每個單位可以抽出來獨立運作。</p>\n<blockquote>\n<p>為什麼可以複用？關於這點，我們得先探討── 元件（Component）是什麼樣的存在？</p>\n</blockquote>\n<p>在 React，一般用 JSX 來描述我們所需要的 DOM elements 結構（它可以用類似 HTML 語法），這些描述結構就是 React element，可以想像 React element 是機器的設計圖，而 React Component 就是機器，一台根據 React element 設計出來的機器，比如下圖放了數個 <code class=\"language-text\">&lt;Line /&gt;</code> 元件，等同於一台台 <code class=\"language-text\">&lt;Line /&gt;</code> 機器，每台都是由同一張設計圖出來的，他們構造相似，但彼此都是獨立的、互不干擾。</p>\n<p><img src=\"https://static.bookstack.cn/projects/reactjs101-zh-tw/Ch03/images/component.png\"></p>\n<h3 id=\"二、單向資料流（Unidirectional-Data-Flow）\" style=\"position:relative;\">二、單向資料流（Unidirectional Data Flow）<a href=\"#%E4%BA%8C%E3%80%81%E5%96%AE%E5%90%91%E8%B3%87%E6%96%99%E6%B5%81%EF%BC%88Unidirectional-Data-Flow%EF%BC%89\" aria-label=\"二、單向資料流（Unidirectional Data Flow） permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>結構雖然差不多，Componenet 卻能依照設定檔的不同來作調整。</p>\n<p>它根據不同的 state 和 props，出現對應的顯示結果（參考下一題），更準確來說，<strong>唯一能影響 UI 變化、觸發 Component 重新渲染的關鍵就是── 資料變動（props 或 state）</strong>。</p>\n<p>與我們過去的習慣截然不同，是當 React 發現 props 或是 state 更新時，就會重繪整個 UI，而不再像以往我們要自行寫顯示邏輯連結兩者，React 藉由「資料一有變動」就全部重繪（Always Redraw）方式，讓我們只需聚焦在資料本身的狀態，實現了單向資料流，讓狀態管理更清晰。</p>\n<hr>\n<blockquote>\n<p><strong>state 跟 props 的差別在哪裡？</strong></p>\n</blockquote>\n<p>在 React 中常常會到「props 或 state 更新時，就會自動渲染」這一句話，透過前面的了解可以知道他們兩者都代表資料來源，但是差別在哪裡？</p>\n<ul>\n<li>props</li>\n</ul>\n<p>上層元件透過 props 傳遞給下層元件的資料，當下層元件一接觸到它，就會做出對應的變化，props 是一個 JavaScript Object 內容，是從外部傳進來元件的變數，不能改變。</p>\n<p>如範例，在上層元件 tag 中指定 <code class=\"language-text\">name</code> 屬性，它會統一放在 Object 作為參數（props）傳進 Welcome 這個元件，元件要存取到資料只需要透過 <code class=\"language-text\">props.name</code> 拿。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Welcome</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">//props</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello, </span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token plain-text\">, </span><span class=\"token punctuation\">{</span>question<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Welcome</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Mike<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// component tags</span></code></pre></div>\n<ul>\n<li>state</li>\n</ul>\n<p>是在元件（Component）內部進行定義，由元件內部進行初始化、自行保存、控制以及修改。它可能會因為上層元件遞進來的 props 而改變，也可能是元件自身行為而改變，而 state 的變動同樣也會引起元件變化。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// state</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>App<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>其實 props 很好理解，它就像以前我們用 function 會拿到的引數，引數傳進來時值就固定了，它是唯讀、不可變的。</p>\n<p>所以，兩者最大的差異在於 state 可以被改變。只不過，並非用賦值方式直接改值，因為狀態（state）本身是 immutable，但我們可以安排一個新的狀態給它，它一改變就會觸發元件重新渲染，可呼叫 <code class=\"language-text\">setState()</code> 方法，來更新元件的資料狀態，並且會呼叫 render 方法來更新 UI。</p>\n<blockquote>\n<p><strong>props.children 是什麼？</strong></p>\n</blockquote>\n<p>props 傳入的屬性，和 Component tag 屬性是一一對應，但有個例外就是 <code class=\"language-text\">props.children</code>，它是內建的屬性，表示該元件下的<strong>所有子元件</strong>，即 tag 與 tag 之間包裹的全部東西</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">FancyBorder</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n       </span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">}</span><span class=\"token plain-text\">  \n    &lt;/ div>\n  );\n}\n\nfunction WelcomeDialog() </span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">FancyBorder</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">早安</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">要去哪裡</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    &lt;/ FancyBorder>\n  );\n}</span></code></pre></div>\n<blockquote>\n<p><strong>為什麼說要少用 state、多用 props？</strong></p>\n</blockquote>\n<p>沒有 state 的叫做無狀態元件，有 state 就是有狀態元件，在 React 一般會鼓勵多寫無狀態元件，要使用 props 而不是 state。</p>\n<p>原因其實很簡單，從上面了解到 props 在相同的输入下，它始終呈現同樣的輸出，因為它本身是不可變的，元件的變動可以預測，但 state 不一樣，state 是元件內部自行管理的資料，自行控制，正因為<strong>狀態會帶來管理上的複雜性</strong>，state 是保留給互動性高、會隨時改變的資料。</p>\n<p>React 的核心精神是<strong>單向資料流</strong>，從 Component 的上層往下流，所以鼓勵多寫無狀態元件，盡量讓共用的 state 能往上層元件放，下層再透過 props 拿到，維持資料流的一致。</p>\n<h2 id=\"參考資料\" style=\"position:relative;\">參考資料<a href=\"#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\" aria-label=\"參考資料 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/47161776\">我們為什麼需要 React？</a></li>\n<li><a href=\"https://www.fooish.com/reactjs/\">React 教學 - React JavaScript UI Library</a></li>\n<li><a href=\"https://www.fooish.com/reactjs/components-and-props.html#props-%E6%98%AF%E5%94%AF%E8%AE%80%E7%9A%84-read-only\">React 元件 (Components) | Props</a></li>\n<li><a href=\"https://medium.com/4cats-io/%E7%AE%A1%E7%90%86-react-%E5%85%83%E4%BB%B6%E7%9A%84%E5%85%A7%E9%83%A8%E7%8B%80%E6%85%8B-be53abe19849\">管理 React 元件的內部狀態</a></li>\n<li><a href=\"https://www.itread01.com/content/1545273246.html\">react~props和state的介紹與使用</a></li>\n<li><a href=\"https://juejin.im/post/6844903978061266957\">react中props和state有什么區别?</a></li>\n<li><a href=\"https://www.bookstack.cn/read/reactjs101-zh-tw/Ch03-reactjs-introduction.md\">ReactJS 與 Component 入門介紹</a></li>\n<li><a href=\"https://zh-hant.reactjs.org/docs/components-and-props.html\">Components 與 Props</a></li>\n</ul>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","tableOfContents":"<ul>\n<li>\n<ul>\n<li><a href=\"/Lidemy/%E5%9C%A8%E7%94%A8%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%85%88%E4%BA%86%E8%A7%A3%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%AD%B8%20React/#%E5%85%83%E4%BB%B6%E5%8C%96%E7%9A%84%E8%A8%AD%E8%A8%88%EF%BC%88component-based%EF%BC%89\">元件化的設計（Component-Based）</a></li>\n<li><a href=\"/Lidemy/%E5%9C%A8%E7%94%A8%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%85%88%E4%BA%86%E8%A7%A3%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%AD%B8%20React/#%E5%84%AA%E9%BB%9E\">優點</a></li>\n<li><a href=\"/Lidemy/%E5%9C%A8%E7%94%A8%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%85%88%E4%BA%86%E8%A7%A3%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%AD%B8%20React/#%E7%BC%BA%E9%BB%9E%E5%8F%8A%E9%99%90%E5%88%B6\">缺點及限制</a></li>\n<li><a href=\"/Lidemy/%E5%9C%A8%E7%94%A8%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%85%88%E4%BA%86%E8%A7%A3%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%AD%B8%20React/#%E4%B8%80%E3%80%81%E5%9F%BA%E6%96%BC%E5%85%83%E4%BB%B6%E5%8C%96%E6%80%9D%E8%80%83%EF%BC%88component%EF%BC%89\">一、基於元件化思考（Component）</a></li>\n<li><a href=\"/Lidemy/%E5%9C%A8%E7%94%A8%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%85%88%E4%BA%86%E8%A7%A3%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%AD%B8%20React/#%E4%BA%8C%E3%80%81%E5%96%AE%E5%90%91%E8%B3%87%E6%96%99%E6%B5%81%EF%BC%88unidirectional-data-flow%EF%BC%89\">二、單向資料流（Unidirectional Data Flow）</a></li>\n</ul>\n</li>\n<li><a href=\"/Lidemy/%E5%9C%A8%E7%94%A8%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%85%88%E4%BA%86%E8%A7%A3%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%AD%B8%20React/#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\">參考資料</a></li>\n</ul>","frontmatter":{"title":"為什麼要學 React？","date":"Nov 29, 2020","tags":["React","Lidemy"],"category":"程式導師計畫","thumbnail":null}}},"pageContext":{"slug":"/Lidemy/在用之前，先了解為什麼要學 React/","previous":{"fields":{"slug":"/Lidemy/談談 Event Loop/"},"frontmatter":{"title":"談談 Event Loop","tags":["JavaScript","Lidemy","Event Loop"],"date":"2020-11-12","category":"程式導師計畫","mark":null,"description":"了解 JavaScript 執行特性及 Event Loop 事件循環機制"}},"next":{"fields":{"slug":"/Lidemy/React Lifecycle：認識生命週期方法及觸發時間點/"},"frontmatter":{"title":"React：認識生命週期方法及觸發時間點","tags":["React","Lidemy"],"date":"2020-12-05","category":"程式導師計畫","mark":null,"description":"元件從準備、渲染到頁面、狀態更新後等各個階段，組成了所謂的 lifecycle"}}}},"staticQueryHashes":["63159454"]}