{"componentChunkName":"component---src-templates-blog-post-js","path":"/Lidemy/React：認識 Hooks/","result":{"data":{"site":{"siteMetadata":{"title":"Travel in Time.","author":"Zoe Yu"}},"markdownRemark":{"id":"c2e5ce9b-7d1a-56dd-b85e-a8a2cbd19e69","excerpt":"什麼是 Hook？ Hook 是一種重複使用邏輯的方法，能用來在不同的 Component 之間重複使用邏輯，也讓 function component 擁有 state 或 class component 的功能。 不能在迴圈、判斷式、或是嵌套 function…","html":"<h3 id=\"什麼是-Hook？\" style=\"position:relative;\">什麼是 Hook？<a href=\"#%E4%BB%80%E9%BA%BC%E6%98%AF-Hook%EF%BC%9F\" aria-label=\"什麼是 Hook？ permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Hook 是一種重複使用邏輯的方法，能用來在不同的 Component 之間重複使用邏輯，也讓 function component 擁有 state 或 class component 的功能。</p>\n<ul>\n<li>不能在迴圈、判斷式、或是嵌套 function 中呼叫 Hook</li>\n<li><strong>只在 React function component 呼叫 Hook</strong>（自定義的 Hook 也是），不要在一般 JavaScript function 中呼叫 Hook，因為這關連到它們連結的問題</li>\n<li>Custom Hook：指的是用 <code class=\"language-text\">use</code> 開頭的方法，且有呼叫到其他 Hook，等於說可以將好幾種功能封裝在一起</li>\n</ul>\n<hr>\n<blockquote>\n<p><strong>Q: React 怎麼知道哪個 component 對應哪個 state？ Hooks 如何與 component 關聯？</strong></p>\n</blockquote>\n<p>每一個 component 有一個「memory cell」的內部列表。</p>\n<p>它們是我們可以放入一些資料的 JavaScript object，當你呼叫像是 <code class=\"language-text\">useState()</code> 的 Hook，它會讀取目前的 cell（或因為是第一次 render 而初始化它），每次重新渲染的時候都可以從這個地方拿到該狀態，並將指標移動到下一個 state，讓 function Component 可以保存自己的狀態。</p>\n<p>就算多個 <code class=\"language-text\">useState()</code> 的呼叫，它們都能取得自己獨有的 local state。</p>\n<hr>\n<h3 id=\"1-內建-Hook：useState\" style=\"position:relative;\">1 內建 Hook：useState<a href=\"#1-%E5%85%A7%E5%BB%BA-Hook%EF%BC%9AuseState\" aria-label=\"1 內建 Hook：useState permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> [state, setState] = useState(initialState);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 會回傳一個 state 的值（value），以及更新該 state 的方法（setter function）</span></span></span></code></pre>\n<ul>\n<li>呼叫用途：宣告了一個會被 React 保留的變數</li>\n<li>參數：唯一的參數要放初始值，可以是 string、number、object 各種型態</li>\n<li>回傳：一對數值，目前的 state 值和可以讓你更新 state 的方法（可以從 event handler 或其他地方呼叫它來更新），setState 方法接收先前的 state，並回傳一個已更新的值</li>\n</ul>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">import</span><span class=\"mtk1\"> React, { useState } </span><span class=\"mtk4\">from</span><span class=\"mtk1\"> </span><span class=\"mtk11\">&#39;react&#39;</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// destructuring</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> Example() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// 宣告一個新的 state 變數「count」及更新變數的方法是「setCount」</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> [count, setCount] = useState(</span><span class=\"mtk5\">0</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> (</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>從 React 引入 <code class=\"language-text\">useState</code> Hook API，呼叫它是用來在 function component 裡面保留 local state。</p>\n<p>舉例來說，在 <code class=\"language-text\">&lt;Example /&gt;</code> 元件中我們呼叫了 useState 去宣告一個名為 count 的變數，一般情況下，變數會在 function 結束時就消失，但 state 變數卻會被 React 保留起來，即 React 在 re-render 元件時仍會記住目前的值，保留著這些 state，讓 function component 可以管理它的內部狀態，使用 setCount 方法將會更新 count 的值，給一個 newState 直接取代。</p>\n<p>在一個 Component 之中可以宣告多個 State，不再需要把各種無關的 State 硬是列在同一個 Object，操作 setState 時也不用同時考慮所有狀態該如何調整。</p>\n<p>注意：由於 <strong>setState 並非即時更新、是非同步的</strong>，因此接下來也會用別的 hook 來解決這個問題。</p>\n<BR>\n<blockquote>\n<p><strong>補充：initialState</strong></p>\n</blockquote>\n<p>initialState 參數只會在初始 render 時使用，在後續 render 時會被忽略。\n如果初始 state 需要通過複雜的計算來獲得，你可以傳入一個 function，它回傳的東西將成為初始值，只在初始 render 時被調用：</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> [state, setState] = useState(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> initialState = someExpensiveComputation(props);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> initialState;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">});</span></span></span></code></pre>\n<blockquote>\n<p><strong>跳過 state 更新</strong></p>\n</blockquote>\n<p>如果 React 偵測到 state 值有所變化就會 re-render 該元件，反之如果還是傳入一樣的值，React 將會跳過子元件的 render 及 effect 的執行，不過它還是需要在跳過 render 之前先渲染它本身的 Component。</p>\n<hr>\n<h3 id=\"2-內建-Hook：useEffect\" style=\"position:relative;\">2 內建 Hook：useEffect<a href=\"#2-%E5%85%A7%E5%BB%BA-Hook%EF%BC%9AuseEffect\" aria-label=\"2 內建 Hook：useEffect permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(didUpdate);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 傳入一個指令</span></span></span></code></pre>\n<p>預設情況下，<code class=\"language-text\">useEffect</code> 會在每一個完整 render 結束後執行裡面的程式碼。</p>\n<h3 id=\"為什麼要呼叫-useEffect\" style=\"position:relative;\">為什麼要呼叫 useEffect<a href=\"#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%91%BC%E5%8F%AB-useEffect\" aria-label=\"為什麼要呼叫 useEffect permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>使用這個 Hook，React 就知道你的 component 在 render 後要做什麼事情，而在 component 內部呼叫 useEffect，讓我們可以拿到 state 和任何 props。</p>\n<p>有一些操作，比如網路請求、監聽事件、訂閱、或手動改變 DOM 等「side effect」，他們可能會影響其它元件，或是在 render 期間還不能觸發的操作，都會被寫在 <code class=\"language-text\">useEffect</code> 裡面，等到 DOM 更新之後才去執行的程式碼。</p>\n<h3 id=\"每次-render-完都要呼叫嗎\" style=\"position:relative;\">每次 render 完都要呼叫嗎<a href=\"#%E6%AF%8F%E6%AC%A1-render-%E5%AE%8C%E9%83%BD%E8%A6%81%E5%91%BC%E5%8F%AB%E5%97%8E\" aria-label=\"每次 render 完都要呼叫嗎 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>但每次 render 就執行一次，並不符合實際上的應用，我們可以選擇讓它在某些值改變的時候才執行，類似監聽某個值的變化來設定 useEffect 執行條件。</p>\n<p>參考 <a href=\"https://zh-hant.reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect\">有條件的觸發 effect</a>，如果它的依賴有改變才會觸發 <code class=\"language-text\">useEffect</code>，確認 array 裡有包含：</p>\n<ol>\n<li>所有在該 component 中會隨時間而變的值（例如 props 和 state）</li>\n<li>在該 effect 中使用到的值</li>\n</ol>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> subscription = props.source.subscribe();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      subscription.unsubscribe();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    };</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  },</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  [props.source],  </span><span class=\"mtk3\">// 只有當 props.source 改變時才會重新建立 subscription</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">);</span></span></span></code></pre>\n<blockquote>\n<p><strong>補充：初始化使用</strong></p>\n</blockquote>\n<p>如果想要 effect 只執行和清除一次（就是 mount 和 unmount 的時候），比如只會在第一次 render 要呼叫的 API，我們可以在第二參數傳遞一個空陣列 （<code class=\"language-text\">[]</code>），意思是，<code class=\"language-text\">useEffect</code> 沒有依賴任何在 props 或 state 的值，所以它的條件不會改變，它永遠不會被再次執行。</p>\n<h3 id=\"useEffect-的回傳用途：清除-effect\" style=\"position:relative;\">useEffect 的回傳用途：清除 effect<a href=\"#useEffect-%E7%9A%84%E5%9B%9E%E5%82%B3%E7%94%A8%E9%80%94%EF%BC%9A%E6%B8%85%E9%99%A4-effect\" aria-label=\"useEffect 的回傳用途：清除 effect permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>當元件要被 unmount 時，我們需要清除 effect 所建立的資源時，同樣是使用 <code class=\"language-text\">useEffect</code>，回傳一個 function，告訴 React 在移除元件前要如何「清理/處理」舊的資源</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> subscription = props.source.subscribe();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// Clean up the subscription</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    subscription.unsubscribe();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  };</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">});</span></span></span></code></pre>\n<hr>\n<h3 id=\"3-內建-Hook：useContext\" style=\"position:relative;\">3 內建 Hook：useContext<a href=\"#3-%E5%85%A7%E5%BB%BA-Hook%EF%BC%9AuseContext\" aria-label=\"3 內建 Hook：useContext permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>讓你不需要巢狀化就可以訂閱 React context，再也不用透過 render props 來得到 value，useContext 則是接收一個 Context 然後直接回傳 Context 裡面的資料。</p>\n<p>先在最上層 Component 以 <code class=\"language-text\">createContext</code> 建立一個 Context Component ，並將要傳遞的資料放到它的參數，接著在下層元件或者更下層，便能直接將 Context Component 傳給 useContext，進而取得 value 裡的資料。這個做法解決了：</p>\n<ol>\n<li>透過 Props 傳遞資料時常常會經過太多層的問題（Props drilling）</li>\n<li>明明不需要該筆資料的 Component 卻擁有資料的情況</li>\n</ol>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 建立一個 Context</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> ContextStore = React.createContext({</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  todos: []</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">})</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 使用 ContextStore</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> Application() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> (</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk13\">&lt;</span><span class=\"mtk4\">ContextStore.Provider</span><span class=\"mtk1\"> </span><span class=\"mtk8\">value</span><span class=\"mtk1\">=</span><span class=\"mtk4\">{</span><span class=\"mtk1\">{todos: [</span><span class=\"mtk11\">&#39;run&#39;</span><span class=\"mtk1\">]}</span><span class=\"mtk4\">}</span><span class=\"mtk13\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk13\">&lt;</span><span class=\"mtk4\">Todos</span><span class=\"mtk1\"> </span><span class=\"mtk13\">/&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk13\">&lt;/</span><span class=\"mtk4\">ContextStore.Provider</span><span class=\"mtk1\"> </span><span class=\"mtk13\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  )</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span></code></pre>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// Todos</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> Todos() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> value = React.useContext(ContextStore)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> (</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk13\">&lt;</span><span class=\"mtk4\">React.Fragment</span><span class=\"mtk13\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk4\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        value.todos.map(todo </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk13\">&lt;</span><span class=\"mtk4\">div</span><span class=\"mtk1\"> </span><span class=\"mtk8\">key</span><span class=\"mtk1\">=</span><span class=\"mtk4\">{</span><span class=\"mtk1\">todo</span><span class=\"mtk4\">}</span><span class=\"mtk13\">&gt;</span><span class=\"mtk4\">{</span><span class=\"mtk1\">todo</span><span class=\"mtk4\">}</span><span class=\"mtk1\"> </span><span class=\"mtk13\">&lt;/</span><span class=\"mtk4\">div</span><span class=\"mtk13\">&gt;</span><span class=\"mtk1\"> )</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk4\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk13\">&lt;/</span><span class=\"mtk1\"> </span><span class=\"mtk4\">React.Fragment</span><span class=\"mtk13\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  )</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<hr>\n<h3 id=\"4-內建-Hook：useRef\" style=\"position:relative;\">4 內建 Hook：useRef<a href=\"#4-%E5%85%A7%E5%BB%BA-Hook%EF%BC%9AuseRef\" aria-label=\"4 內建 Hook：useRef permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>主要有兩個功能，一個是存放 mutable 的值，一個是可以抓取 DOM 節點。</p>\n<h3 id=\"1-存放可變的值\" style=\"position:relative;\">1. 存放可變的值<a href=\"#1-%E5%AD%98%E6%94%BE%E5%8F%AF%E8%AE%8A%E7%9A%84%E5%80%BC\" aria-label=\"1 存放可變的值 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>跟使用 useState 的改變值區別在於，它不會導致 re-render。useRef 回傳一個可變的 ref object，它的 <code class=\"language-text\">.current</code> 屬性被初始化為傳入的參數，回傳的 object 在元件的生命週期都將保持不變。</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> refContainer = useRef(initialValue);</span></span></span></code></pre>\n<h3 id=\"2-抓取-DOM\" style=\"position:relative;\">2. 抓取 DOM<a href=\"#2-%E6%8A%93%E5%8F%96-DOM\" aria-label=\"2 抓取 DOM permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>useRef 更多的應用，是可以作為讓我們抓取到 DOM 節點的 hook。</p>\n<p>呼叫 useRef 建立出一個物件實體，null 表示初始值設定為 null，將建立好的物件丟入我們要抓取的 DOM 元素的 ref attribute 中，做完這件事可以想像成我們對這個 input 有了控制權，<code class=\"language-text\">&lt;input /&gt;</code> 的 DOM 透過 ref 存進 inputRef。</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> inputRef = useRef(</span><span class=\"mtk4\">null</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk13\">&lt;</span><span class=\"mtk4\">input</span><span class=\"mtk1\"> </span><span class=\"mtk8\">ref</span><span class=\"mtk1\">=</span><span class=\"mtk4\">{</span><span class=\"mtk1\">inputRef</span><span class=\"mtk4\">}</span><span class=\"mtk1\"> </span><span class=\"mtk8\">placeholder</span><span class=\"mtk1\">=</span><span class=\"mtk11\">&quot;Please input somthing&quot;</span><span class=\"mtk13\">/&gt;</span></span></span></code></pre>\n<p>對現在綁定的 DOM node 做操作，需要到 <code class=\"language-text\">.current</code> properity 中</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 有了 useRef 就可以做到例如頁面刷新後自動 foucs 在某個欄位</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> handleClick = () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\tinputRef.current.focus();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<hr>\n<h3 id=\"5-內建-Hook：useMemo、useCallback-和-memo\" style=\"position:relative;\">5 內建 Hook：useMemo、useCallback 和 memo<a href=\"#5-%E5%85%A7%E5%BB%BA-Hook%EF%BC%9AuseMemo%E3%80%81useCallback-%E5%92%8C-memo\" aria-label=\"5 內建 Hook：useMemo、useCallback 和 memo permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>在 function Component，容易觸發重新渲染，如果遇到大型的網站，有大量的元件、子元件不斷被 re-render，將造成瀏覽器的重大負擔。而要進行 React 優化，最常見就是透過 useMemo()、memo 和 useCallback() 來搭配使用。</p>\n<h3 id=\"1-memo\" style=\"position:relative;\">1. memo<a href=\"#1-memo\" aria-label=\"1 memo permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>父層狀態變了，底下的每個子元件都會做 re-render，就算它依賴的 props 或 state 沒有改變，React 提供了 <code class=\"language-text\">memo</code> 來幫助我們解決這個問題，<strong>它是專用於 Component 的方法</strong>。</p>\n<p>將元件用 <code class=\"language-text\">memo</code> 包起來， memo 會幫忙檢測它的 props 是否有變動，減少元件被渲染的機會，讓 React 幫我們記住原本的 props。</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"11\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">cosnt MemoButton = memo(Button)</span></span></span></code></pre>\n<p>然而，<code class=\"language-text\">memo</code> 是利用 shallowly compare 的方法確認 props 的值是否一樣， shallowly compare 在 props 是 Number 或 String 比較的是數值，基本型態的值不受影響，但當 props 是 Object 時，比較的卻是記憶體位置（reference）。正因為父元件重新渲染時，在父元件宣告的 Object 是會被重新分配記憶體位址，我們在這時候利用 <code class=\"language-text\">memo</code> 來防止重新渲染就會失效。</p>\n<p>所以，<code class=\"language-text\">memo</code> 也有提供了第二個參數，讓我們可以自訂比較 props 的方法。</p>\n<h3 id=\"2-useCallback-使用\" style=\"position:relative;\">2. useCallback 使用<a href=\"#2-useCallback-%E4%BD%BF%E7%94%A8\" aria-label=\"2 useCallback 使用 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>除了上述方式，可以利用 <code class=\"language-text\">useCallback()</code> 讓 React 可以自動記住 Object 的記憶體位址</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"12\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> memoizedCallback = useCallback(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    doSomething(a, b);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  },</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  [a, b],</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>裡面如果傳的是會重新產生的 object 或 function，就是記憶體可能變動的東西，用 <code class=\"language-text\">useCallback</code> 去把該他們包裹，React 幫你記憶起來，用法和 useEffect 有點像，第二個陣列參數放要偵測變動的東西（dependency），在父元件重新渲染時，不重新分配記憶體位址，而造成子元件重複渲染。</p>\n<p>而常常讓人搞混的 <code class=\"language-text\">useMemo()</code>，其實和父元件無關，它主要用在讓複雜的程式碼或運算，不要在重新渲染時再次執行。</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"jsx\" data-index=\"13\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">cosnt s = useMemo(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        color: value? </span><span class=\"mtk11\">&#39;red&#39;</span><span class=\"mtk1\">: </span><span class=\"mtk11\">&#39;blue&#39;</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}, [value]) </span></span></span></code></pre>\n<hr>\n<h2 id=\"參考資料\" style=\"position:relative;\">參考資料<a href=\"#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\" aria-label=\"參考資料 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li><a href=\"https://zh-hant.reactjs.org/docs/hooks-overview.html\">Hook 概觀</a></li>\n<li><a href=\"https://zh-hant.reactjs.org/docs/hooks-state.html\">使用 State Hook</a></li>\n<li><a href=\"https://zh-hant.reactjs.org/docs/hooks-reference.html#usecontext\">Hooks API 參考</a></li>\n<li><a href=\"https://zh-hant.reactjs.org/docs/hooks-effect.html\">使用 Effect Hook</a></li>\n<li><a href=\"https://medium.com/@Lieutenant1992/react-hooks-%E4%B8%8A-usestate-useeffect-37f45056fea8\">React Hooks (上)-useState&#x26;useEffect</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10221937\">Day 24】 useRef</a></li>\n<li><a href=\"https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/react-optimize-performance-using-memo-usecallback-usememo-a76b6b272df3\">React 性能優化那件大事，使用 memo、useCallback、useMemo</a></li>\n</ul>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .visual-studio-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .visual-studio-dark .mtk4 { color: #569CD6; }\n  .visual-studio-dark .mtk1 { color: #D4D4D4; }\n  .visual-studio-dark .mtk3 { color: #6A9955; }\n  .visual-studio-dark .mtk11 { color: #CE9178; }\n  .visual-studio-dark .mtk5 { color: #B5CEA8; }\n  .visual-studio-dark .mtk13 { color: #808080; }\n  .visual-studio-dark .mtk8 { color: #9CDCFE; }\n  .visual-studio-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","tableOfContents":"<ul>\n<li>\n<ul>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#%E4%BB%80%E9%BA%BC%E6%98%AF-hook%EF%BC%9F\">什麼是 Hook？</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#1-%E5%85%A7%E5%BB%BA-hook%EF%BC%9Ausestate\">1 內建 Hook：useState</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#2-%E5%85%A7%E5%BB%BA-hook%EF%BC%9Auseeffect\">2 內建 Hook：useEffect</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%91%BC%E5%8F%AB-useeffect\">為什麼要呼叫 useEffect</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#%E6%AF%8F%E6%AC%A1-render-%E5%AE%8C%E9%83%BD%E8%A6%81%E5%91%BC%E5%8F%AB%E5%97%8E\">每次 render 完都要呼叫嗎</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#useeffect-%E7%9A%84%E5%9B%9E%E5%82%B3%E7%94%A8%E9%80%94%EF%BC%9A%E6%B8%85%E9%99%A4-effect\">useEffect 的回傳用途：清除 effect</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#3-%E5%85%A7%E5%BB%BA-hook%EF%BC%9Ausecontext\">3 內建 Hook：useContext</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#4-%E5%85%A7%E5%BB%BA-hook%EF%BC%9Auseref\">4 內建 Hook：useRef</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#1-%E5%AD%98%E6%94%BE%E5%8F%AF%E8%AE%8A%E7%9A%84%E5%80%BC\">1. 存放可變的值</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#2-%E6%8A%93%E5%8F%96-dom\">2. 抓取 DOM</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#5-%E5%85%A7%E5%BB%BA-hook%EF%BC%9Ausememo%E3%80%81usecallback-%E5%92%8C-memo\">5 內建 Hook：useMemo、useCallback 和 memo</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#1-memo\">1. memo</a></li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#2-usecallback-%E4%BD%BF%E7%94%A8\">2. useCallback 使用</a></li>\n</ul>\n</li>\n<li><a href=\"/Lidemy/React%EF%BC%9A%E8%AA%8D%E8%AD%98%20Hooks/#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\">參考資料</a></li>\n</ul>","frontmatter":{"title":"React：認識 Hooks","type":"coding","date":"Dec 07, 2020","tags":["React","Lidemy"],"category":"程式導師計畫","log":null,"thumbnail":null}}},"pageContext":{"slug":"/Lidemy/React：認識 Hooks/","previous":{"fields":{"slug":"/Lidemy/React Lifecycle：認識生命週期方法及觸發時間點/"},"frontmatter":{"title":"React Lifecycle：認識生命週期方法及觸發時間點","tags":["React","Lidemy"],"date":"2020-12-05","category":"程式導師計畫","mark":null,"description":"元件從準備、渲染到頁面、狀態更新後等各個階段，組成了所謂的 lifecycle","log":null}},"next":{"fields":{"slug":"/Lidemy/React：class component 與 function component 的差別/"},"frontmatter":{"title":"React：Class component 與 Functional component 的差別","tags":["React","Lidemy"],"date":"2020-12-10","category":"程式導師計畫","mark":null,"description":"談談兩者在渲染、效能、生命週期實現的異同","log":null}}}},"staticQueryHashes":["63159454"]}