{"componentChunkName":"component---src-templates-blog-post-js","path":"/Lidemy/React Lifecycle：認識生命週期方法及觸發時間點/","result":{"data":{"site":{"siteMetadata":{"title":"Travel in Time.","author":"Zoe Yu"}},"markdownRemark":{"id":"462672d4-cda7-5cd6-9d1b-2bf394854d07","excerpt":"什麼是 Component 的生命週期？ 不同於 function component，class component…","html":"<blockquote>\n<p>什麼是 Component 的生命週期？</p>\n</blockquote>\n<p>不同於 function component，class component 是一個物件，裡面有許多內建函式，他們分別對應一個元件從準備、渲染到頁面、狀態更新後重新渲染、從頁面上移除前…等各個階段（時間點），組成了所謂的 Lifecycle。</p>\n<p>這些 Lifecycle 方法，讓我們得以掌握元件的生命週期，在開發過程中某些特定時刻能執行我們需要的程式，例如載入完元件後才去非同步抓取資料，更新 props 觸發處理事件。</p>\n<hr>\n<h3 id=\"一、生命週期各個階段\" style=\"position:relative;\">一、生命週期各個階段<a href=\"#%E4%B8%80%E3%80%81%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E5%90%84%E5%80%8B%E9%9A%8E%E6%AE%B5\" aria-label=\"一、生命週期各個階段 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h5 id=\"1-Mounting-階段：會在元件被建立時被執行\" style=\"position:relative;\">1 Mounting 階段：會在元件被建立時被執行<a href=\"#1-Mounting-%E9%9A%8E%E6%AE%B5%EF%BC%9A%E6%9C%83%E5%9C%A8%E5%85%83%E4%BB%B6%E8%A2%AB%E5%BB%BA%E7%AB%8B%E6%99%82%E8%A2%AB%E5%9F%B7%E8%A1%8C\" aria-label=\"1 Mounting 階段：會在元件被建立時被執行 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>當一個 component 被建立且加入 DOM tree 中時，其生命週期將會依照下列的順序呼叫這些方法：</p>\n<ul>\n<li>constructor()</li>\n<li>static getDerivedStateFromProps()</li>\n<li>render()</li>\n<li>componentDidMount()</li>\n</ul>\n<h5 id=\"2-Updateing-階段\" style=\"position:relative;\">2 Updateing 階段<a href=\"#2-Updateing-%E9%9A%8E%E6%AE%B5\" aria-label=\"2 Updateing 階段 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>當 prop 或 state 有變化時，就會產生狀態更新。當一個 component 處於更新階段，其生命週期將會依照下列的順序呼叫這些方法：</p>\n<ul>\n<li>getDerivedStateFromProps()</li>\n<li>shouldComponentUpdate()</li>\n<li>render()</li>\n<li>getSnapshotBeforeUpdate()</li>\n<li>componentDidUpdate()</li>\n</ul>\n<h5 id=\"3-Unmounting-階段\" style=\"position:relative;\">3 Unmounting 階段<a href=\"#3-Unmounting-%E9%9A%8E%E6%AE%B5\" aria-label=\"3 Unmounting 階段 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>當一個 component 被從 DOM 中移除時，以下方法將會被呼叫：</p>\n<ul>\n<li>componentWillUnmount()</li>\n</ul>\n<h5 id=\"4-錯誤處理\" style=\"position:relative;\">4 錯誤處理<a href=\"#4-%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86\" aria-label=\"4 錯誤處理 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>當一個 component 在 render 過程、生命週期、或在某個 child component 的 constructor 中發生錯誤時，會呼叫以下方法處理：</p>\n<ul>\n<li>getDerivedStateFromError()</li>\n<li>componentDidCatch()</li>\n</ul>\n<p><img src=\"https://iamian.cc/static/56e1ae1a077d66ecc3899de3eec3e5d6/acfc1/react-life.png\"></p>\n<hr>\n<h3 id=\"二、常用的生命週期方法\" style=\"position:relative;\">二、常用的生命週期方法<a href=\"#%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95\" aria-label=\"二、常用的生命週期方法 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h4 id=\"1-constructor\" style=\"position:relative;\">1. constructor<a href=\"#1-constructor\" aria-label=\"1 constructor permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>會在 mount 之前被呼叫，用來建構並初始化物件，這邊繼承 <code class=\"language-text\">React.Component</code>，當你需要初始化 state 或綁定方法時，才需要實作它。建立 constructor 時，你應該先呼叫 <code class=\"language-text\">super()</code>，帶入 props 參數，否則 <code class=\"language-text\">this.props</code> 的值會出現 undefined 問題。</p>\n<p>參考 <a href=\"https://https://overreacted.io/why-do-we-write-super-props/\">Why Do We Write super(props)?</a> 一文，super 會繼承父類別（指 React.Component），當我們呼叫過後，它才會配置 <code class=\"language-text\">this.props = props</code>，這時才能在建構子中使用 this。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> counter<span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">handleClick</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>只有在 constructor 裡面才可以指定 <code class=\"language-text\">this.state</code> 值，其它地方則需要使用到 <code class=\"language-text\">this.setState()</code> 方法</li>\n<li>constructor 裡面只用來設置初始化和綁定方法</li>\n<li>不要做任何會產生 side effect 或 subscription 的事，那些應該在渲染完之後進行，例如使用 <code class=\"language-text\">componentDidMount()</code></li>\n</ul>\n<blockquote>\n<p><strong>Q: 常見錯誤：直接複製 prop 的值到 state 中！</strong></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> color<span class=\"token operator\">:</span> props<span class=\"token punctuation\">.</span>color <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// don't do that!å</span>\n\n\n  <span class=\"token comment\">// 1. 多此一舉，可以直接用 this.props.color</span>\n  <span class=\"token comment\">// 2. 產生 bug，prop 產生的更新根本不會出現在 state 中</span>\n  <span class=\"token comment\">// 3. 不能讓 state 依賴 prop</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4 id=\"2-render\" style=\"position:relative;\">2. render<a href=\"#2-render\" aria-label=\"2 render permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">render()</code> 是 class component 中唯一一個<strong>必須實作</strong>的方法。</p>\n<p>當 render 被呼叫時，它將會檢視 this.props 和 this.state 中的變化，並回傳透過 JSX 建立的 React element、Fragment、Portals 或 null，也就是說使用 setState 方法、更新父元件傳遞的 props，都會執行到 <code class=\"language-text\">render()</code>。</p>\n<ul>\n<li>pure function</li>\n<li>不會改變 component 的 state，每次呼叫時都會回傳同樣的結果</li>\n<li>不會直接和瀏覽器有所互動</li>\n</ul>\n<blockquote>\n<p><strong>Q: 更新狀態一定會呼叫到 render 嗎？</strong></p>\n</blockquote>\n<p>大部分都會，唯一的例外情況是當 <code class=\"language-text\">shouldComponentUpdate()</code> 回傳的值為 false 的話，render() 將不會被呼叫到。</p>\n<h4 id=\"3-componentDidMount\" style=\"position:relative;\">3. componentDidMount<a href=\"#3-componentDidMount\" aria-label=\"3 componentDidMount permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>在 component 被加入 DOM tree 中後，<code class=\"language-text\">componentDidMount()</code> 會馬上被調用。</p>\n<p>可以在該方法裡面呼叫 <code class=\"language-text\">setState()</code>，雖然會觸發一次額外的 render，但是是在瀏覽器畫面更新之前發生，使用者不會看見兩次 render 中過渡時期的狀態，只是可能導致效能上問題。</p>\n<ul>\n<li>執行 ajax，適合進行網路請求</li>\n<li>設定 subscription</li>\n<li>綁定 DOM 事件</li>\n</ul>\n<h4 id=\"4-componentDidUpdate\" style=\"position:relative;\">4. componentDidUpdate<a href=\"#4-componentDidUpdate\" aria-label=\"4 componentDidUpdate permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">,</span> snapshot<span class=\"token punctuation\">)</span></code></pre></div>\n<p>用途和 componentDidMount 相似，區別在於它是用在 Updating 階段，可以在這裡寫</p>\n<ol>\n<li>對 DOM 進行運作的處理</li>\n<li>網路請求</li>\n</ol>\n<p>記得設定條件，例如比較前後的 prop，不然每次重新渲染都執行一遍，很影響效能</p>\n<h4 id=\"5-componentWillUnmount\" style=\"position:relative;\">5. componentWillUnmount<a href=\"#5-componentWillUnmount\" aria-label=\"5 componentWillUnmount permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>在 component 要從畫面上被移除前（unmount）馬上被呼叫，在這個方法內進行任何狀態的清除，像是取消計時和網路請求或是移除監聽。</p>\n<p>常用的生命週期方法大概就這幾種，其它比較少用的可以參考這篇 <a href=\"https://zh-hant.reactjs.org/docs/react-component.html\">React.Component</a> 和 <a href=\"https://zh-hant.reactjs.org/docs/state-and-lifecycle.html\">State 和生命週期</a> 有詳細的介紹與範例。</p>\n<hr>\n<h2 id=\"三、元件渲染順序\" style=\"position:relative;\">三、元件渲染順序<a href=\"#%E4%B8%89%E3%80%81%E5%85%83%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%A0%86%E5%BA%8F\" aria-label=\"三、元件渲染順序 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>Mounting\n父元件先執行到 <code class=\"language-text\">render()</code> 後，再來開始執行子元件的 Mounting 生命週期，最後執行完子元件的 <code class=\"language-text\">componentDidMount()</code> 後，再回頭執行父元件的 <code class=\"language-text\">componentDidMount()</code></li>\n<li>Updating\n父元件執行到 render 後，換子元件執行直到 <code class=\"language-text\">getSnapshotBeforeUpdate()</code>，會再回父元件執行 <code class=\"language-text\">getSnapshotBeforeUpdate()</code>，然後再執行子元件的 <code class=\"language-text\">componentDidUpdate()</code>，再回父元件執行 <code class=\"language-text\">componentDidUpdate()</code></li>\n<li>UnMounting\n父元件先執行 componentWillUnmount，再來是子元件執行</li>\n</ul>\n<h2 id=\"參考資料\" style=\"position:relative;\">參考資料<a href=\"#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\" aria-label=\"參考資料 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li><a href=\"https://zh-hant.reactjs.org/docs/react-component.html\">React.Component</a></li>\n<li><a href=\"https://https://iamian.cc/reactlife/\">React Life Cycle 生命週期更新版，父子元件執行順序</a></li>\n</ul>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","tableOfContents":"<ul>\n<li>\n<ul>\n<li>\n<p><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#%E4%B8%80%E3%80%81%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E5%90%84%E5%80%8B%E9%9A%8E%E6%AE%B5\">一、生命週期各個階段</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#1-mounting-%E9%9A%8E%E6%AE%B5%EF%BC%9A%E6%9C%83%E5%9C%A8%E5%85%83%E4%BB%B6%E8%A2%AB%E5%BB%BA%E7%AB%8B%E6%99%82%E8%A2%AB%E5%9F%B7%E8%A1%8C\">1 Mounting 階段：會在元件被建立時被執行</a></li>\n<li><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#2-updateing-%E9%9A%8E%E6%AE%B5\">2 Updateing 階段</a></li>\n<li><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#3-unmounting-%E9%9A%8E%E6%AE%B5\">3 Unmounting 階段</a></li>\n<li><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#4-%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86\">4 錯誤處理</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95\">二、常用的生命週期方法</a></p>\n<ul>\n<li><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#1-constructor\">1. constructor</a></li>\n<li><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#2-render\">2. render</a></li>\n<li><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#3-componentdidmount\">3. componentDidMount</a></li>\n<li><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#4-componentdidupdate\">4. componentDidUpdate</a></li>\n<li><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#5-componentwillunmount\">5. componentWillUnmount</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#%E4%B8%89%E3%80%81%E5%85%83%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%A0%86%E5%BA%8F\">三、元件渲染順序</a></li>\n<li><a href=\"/Lidemy/React%20Lifecycle%EF%BC%9A%E8%AA%8D%E8%AD%98%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%B8%E7%99%BC%E6%99%82%E9%96%93%E9%BB%9E/#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\">參考資料</a></li>\n</ul>","frontmatter":{"title":"React：認識生命週期方法及觸發時間點","date":"Dec 05, 2020","tags":["React","Lidemy"],"category":"程式導師計畫","thumbnail":null}}},"pageContext":{"slug":"/Lidemy/React Lifecycle：認識生命週期方法及觸發時間點/","previous":{"fields":{"slug":"/Lidemy/在用之前，先了解為什麼要學 React/"},"frontmatter":{"title":"為什麼要學 React？","tags":["React","Lidemy"],"date":"2020-11-29","category":"程式導師計畫","mark":null,"description":"談談 React 的核心，元件化及單向資料流"}},"next":{"fields":{"slug":"/Lidemy/React：認識 Hooks/"},"frontmatter":{"title":"React：認識 Hooks","tags":["React","Lidemy"],"date":"2020-12-07","category":"程式導師計畫","mark":null,"description":"Hook 是一種重複使用邏輯的方法，讓 function component 可以擁有 state 的功能。"}}}},"staticQueryHashes":["63159454"]}