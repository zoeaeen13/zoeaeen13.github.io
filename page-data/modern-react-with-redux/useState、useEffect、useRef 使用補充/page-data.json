{"componentChunkName":"component---src-templates-blog-post-js","path":"/modern-react-with-redux/useState、useEffect、useRef 使用補充/","result":{"data":{"site":{"siteMetadata":{"title":"Travel in Time.","author":"Zoe Yu"}},"markdownRemark":{"id":"e793890d-b683-5c22-9d2e-5d96c23f6169","excerpt":"Hooks 提供 functional component 可以擁有狀態、類似生命週期的方法  useState 使用 array Destructuring，快速存取陣列裡面的元素 只要調用到 setter function，元件就會觸發 re-render，而 state…","html":"<p>Hooks 提供 functional component 可以擁有狀態、類似生命週期的方法</p>\n<p><img src=\"https://i.imgur.com/qI4UX9i.png\"></p>\n<hr>\n<h4 id=\"useState\" style=\"position:relative;\">useState<a href=\"#useState\" aria-label=\"useState permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>使用 array Destructuring，快速存取陣列裡面的元素</li>\n<li>只要調用到 setter function，元件就會觸發 re-render，而 state 的初始值將不會再被使用（預設 null），直接被新值取代</li>\n</ul>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"javascript\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">import</span><span class=\"mtk1\"> React, { useState } </span><span class=\"mtk4\">from</span><span class=\"mtk1\"> </span><span class=\"mtk11\">&#39;react&#39;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> [activeIndex, setActiveIndex] = useState(</span><span class=\"mtk4\">null</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 第一個參數，放某個會被 React 保留的變數引用</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 第二個參數，是一個可以用來更新該變數的 setter function</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 接受一個參數，作為 state 初始值</span></span></span></code></pre>\n<p>class Component 可以同時定義和更改多個狀態，但 functional component 卻需要多次調用</p>\n<hr>\n<br>\n<h4 id=\"useEffect\" style=\"position:relative;\">useEffect<a href=\"#useEffect\" aria-label=\"useEffect permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"javascript\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// 要執行的程式碼</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}, [])</span></span></span></code></pre>\n<p>有三種方法可以配置 useEffect 使用，達到生命週期的作用</p>\n<ol>\n<li>第一次渲染元件時執行</li>\n<li>第一次渲染時、或任何時候 re-render 完執行（不放第二個參數）</li>\n<li>第一次渲染時、或在某些數據改變時才執行</li>\n</ol>\n<p><img src=\"https://i.imgur.com/dmzIXYt.png\"></p>\n<p>useEffect 第二個參數是一陣列，裡面放的東西不同，將控制什麼時候執行程式碼。如果放多個元素，只要任一改變就會觸發</p>\n<hr>\n<BR>\n<h5 id=\"Q-useEffect-裡面放-async-function？\" style=\"position:relative;\">Q: useEffect 裡面放 async function？<a href=\"#Q-useEffect-%E8%A3%A1%E9%9D%A2%E6%94%BE-async-function%EF%BC%9F\" aria-label=\"Q useEffect 裡面放 async function？ permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>注意 useEffect 要執行的程式碼，不能直接寫 async function</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"javascript\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> [term, setTerm] = useState(</span><span class=\"mtk11\">&#39;&#39;</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(</span><span class=\"mtk4\">async</span><span class=\"mtk1\"> () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">await</span><span class=\"mtk1\"> axios(</span><span class=\"mtk11\">&#39;XXX&#39;</span><span class=\"mtk1\">)... </span><span class=\"mtk3\">// 🔴</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}, [term])</span></span></span></code></pre>\n<p>可透過以下幾種方式解決：</p>\n<ol>\n<li>在 useEffect 裡面定義一個 async function 執行</li>\n<li>把 async function 變成 IIFE，立即調用（和上面差不多）</li>\n<li>使用 Promise</li>\n</ol>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"javascript\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> [term, setTerm] = useState(</span><span class=\"mtk11\">&#39;&#39;</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// #1 設一個 helper function</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> search = </span><span class=\"mtk4\">async</span><span class=\"mtk1\"> () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">await</span><span class=\"mtk1\"> axios.get(</span><span class=\"mtk11\">&#39;XXX&#39;</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  search()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}, [term])</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// #2 和 #1 差不多，只是少掉變數宣告</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  (</span><span class=\"mtk4\">async</span><span class=\"mtk1\"> () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">await</span><span class=\"mtk1\"> axios.get(</span><span class=\"mtk11\">&#39;XXX&#39;</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  })()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}, [term])</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// #3 promise chain</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  axios.get(</span><span class=\"mtk11\">&#39;XXX&#39;</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  .then((response) </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    console.log(response.data)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  })</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}, [term])</span></span></span></code></pre>\n<hr>\n<BR>\n<h5 id=\"Q-useEffect-的-cleanup-function-怎麼使用？\" style=\"position:relative;\">Q: useEffect 的 cleanup function 怎麼使用？<a href=\"#Q-useEffect-%E7%9A%84-cleanup-function-%E6%80%8E%E9%BA%BC%E4%BD%BF%E7%94%A8%EF%BC%9F\" aria-label=\"Q useEffect 的 cleanup function 怎麼使用？ permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>常碰到一個情境：使用者停止輸入後，延遲幾秒才送出搜尋，避免短時間發出多個 request。</p>\n<p>延續上面例子，可以在 term 改變後設定計時器，每 500 毫秒去 call 一次 API 搜尋，而流程會像下圖，第一次 input 改變時設定一個計時，第二次 input 在 500 毫秒以內改變就取消上一個計時，重新設定下一個…</p>\n<p><img src=\"https://i.imgur.com/RAMXi8H.jpg\"></p>\n<p>使用 setTimeout 創建計時器， setTimeout 會返回一個數字或整數標示計時器，可以利用 clearTimeout 來清除它，這樣裡面的程式碼就不會執行</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"javascript\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> search = </span><span class=\"mtk4\">async</span><span class=\"mtk1\"> () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">await</span><span class=\"mtk1\"> axios.get(</span><span class=\"mtk11\">&#39;XXX&#39;</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// 每次延遲 500 ms 發出請求</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  setTimeout(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">if</span><span class=\"mtk1\"> (term) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      search()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }, </span><span class=\"mtk5\">500</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}, [term])</span></span></span></code></pre>\n<p><strong>但是，清除的時機點是什麼？</strong></p>\n<p>在 useEffect 裡面，只能回傳一個特定類型的值，就是 function，也是所謂的清理函數 <code class=\"language-text\">cleanup function</code>，而它的清理功能</p>\n<ul>\n<li>會在元件從 UI 中移除之前運行</li>\n<li>元件渲染多次時，每次執行 useEffect 主要程式碼之前會運行</li>\n</ul>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"javascript\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// main function</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> search = </span><span class=\"mtk4\">async</span><span class=\"mtk1\"> () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">await</span><span class=\"mtk1\"> axios.get(</span><span class=\"mtk11\">&#39;XXX&#39;</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> timeoutId = setTimeout(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">if</span><span class=\"mtk1\"> (term) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      search()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }, </span><span class=\"mtk5\">500</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// cleanup function</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    clearTimeout(timeoutId)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}, [term])</span></span></span></code></pre>\n<p>第一次渲染時，會執行整個 arrow function 的內容，並 return 一個清理函數，React 會將清理函數保留起來。</p>\n<p>當要再次執行 arrow function 內容時，React 會先調用清理函數（第一次執行時返回的東西），接著才執行 arrow function，然後回傳清理函數，順序如下</p>\n<p><img src=\"https://i.imgur.com/EsMAc3m.png\"></p>\n<hr>\n<BR>\n<h4 id=\"useRef-使用\" style=\"position:relative;\">useRef 使用<a href=\"#useRef-%E4%BD%BF%E7%94%A8\" aria-label=\"useRef 使用 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>利用 Refs 系統，訪問由 JSX 所產生真正的 DOM element，代替 <code class=\"language-text\">document.querySelector</code> 使用。</p>\n<p>ref 是一個 JS 物件，有一個 current 屬性會指向其綁定的 DOM 節點，之前在 class componenet 裡面就是用 <code class=\"language-text\">React.createRef()</code> 設定，在 Hooks 裡面也有提供類似的 useRef 方法。</p>\n<p>以設計下拉選單為例，實作點擊頁面其他部分要收起選單：\n首先，第一次渲染下拉元件時，在 useEffect 為 body 添加 click 事件監聽，理想來說，當事件最後冒泡到 body 就會執行關閉選單？</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"javascript\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    document.body.addEventListener(</span><span class=\"mtk11\">&#39;click&#39;</span><span class=\"mtk1\">, () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        setOpen(</span><span class=\"mtk4\">false</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    })</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}, [])</span></span></span></code></pre>\n<p>然而，Dropdown 元件中會執行到 setOpen 的還有其他點擊事件，以為是按照冒泡的順序由下往上傳遞，但實際順序卻和想像不太一樣。</p>\n<blockquote>\n<p>因執行順序問題，竟然發生又打開選單的狀況？</p>\n</blockquote>\n<p><strong>在 JSX 元件上面綁的監聽器，是通過 react 來連結，使用原生 JS 寫法連結的事件反而最先被調用</strong>，所以正確執行順序如下，當點擊 Dropdown 選項時：</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"javascript\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk5\">1</span><span class=\"mtk1\"> 用 addEventListenr 綁定的事件</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk5\">2</span><span class=\"mtk1\"> 子元件綁定的 click 事件</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk5\">3</span><span class=\"mtk1\"> 父元件綁定的 click 事件</span></span></span></code></pre>\n<p><img src=\"https://i.imgur.com/GELW4iO.png\"></p>\n<p>所以，要排除 body click 的某些情況，可以使用 useRef 參照其 DOM 元素</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"javascript\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  document.body.addEventListener(</span><span class=\"mtk11\">&#39;click&#39;</span><span class=\"mtk1\">, (event) </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// 確認目前點擊的元素是否在 Dropdown 裡</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">if</span><span class=\"mtk1\"> (dropDownRef.current.contains(event.target)) </span><span class=\"mtk4\">return</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    setOpen(</span><span class=\"mtk4\">false</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  })</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">})</span></span></span></code></pre>\n<p>不過要注意監聽器的清理，當元件從 DOM 上消失時，所有添加到內部元素的 ref 會被設定成 null（因為沒有東西可以引用了），但是監聽器仍然存在，可能會造成 <code class=\"language-text\">null.current.contains</code> 的錯誤狀況</p>\n<p>記得利用上面提到的 useEffect 清理功能，當元件從畫面上移掉時，關閉監聽器</p>\n<pre class=\"grvsc-container visual-studio-dark\" data-language=\"javascript\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">useEffect(() </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> onBodyClick = (event) </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk4\">if</span><span class=\"mtk1\"> (dropDownRef.current.contains(event.target)) </span><span class=\"mtk4\">return</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        setOpen(</span><span class=\"mtk4\">false</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    })</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    document.body.addEventListener(</span><span class=\"mtk11\">&#39;click&#39;</span><span class=\"mtk1\">, onBodyClick)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// cleanup function</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">return</span><span class=\"mtk1\"> () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        document.body.removeEventListener(</span><span class=\"mtk11\">&#39;click&#39;</span><span class=\"mtk1\">, onBodyClick)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">})</span></span></span></code></pre>\n<blockquote>\n<h6 id=\"PS-補充\" style=\"position:relative;\">P.S 補充<a href=\"#PS-%E8%A3%9C%E5%85%85\" aria-label=\"PS 補充 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h6>\n<p>React v17 之後，監聽器要加上第三個參數 => <code class=\"language-text\">{ capture: true }</code>，參考 <a href=\"https://reactjs.org/blog/2020/08/10/react-v17-rc.html#fixing-potential-issues\">Fixing Potential Issues</a></p>\n</blockquote>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .visual-studio-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .visual-studio-dark .mtk4 { color: #569CD6; }\n  .visual-studio-dark .mtk1 { color: #D4D4D4; }\n  .visual-studio-dark .mtk11 { color: #CE9178; }\n  .visual-studio-dark .mtk3 { color: #6A9955; }\n  .visual-studio-dark .mtk5 { color: #B5CEA8; }\n  .visual-studio-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","tableOfContents":"<ul>\n<li><a href=\"/modern-react-with-redux/useState%E3%80%81useEffect%E3%80%81useRef%20%E4%BD%BF%E7%94%A8%E8%A3%9C%E5%85%85/#usestate\">useState</a></li>\n<li>\n<p><a href=\"/modern-react-with-redux/useState%E3%80%81useEffect%E3%80%81useRef%20%E4%BD%BF%E7%94%A8%E8%A3%9C%E5%85%85/#useeffect\">useEffect</a></p>\n<ul>\n<li><a href=\"/modern-react-with-redux/useState%E3%80%81useEffect%E3%80%81useRef%20%E4%BD%BF%E7%94%A8%E8%A3%9C%E5%85%85/#q-useeffect-%E8%A3%A1%E9%9D%A2%E6%94%BE-async-function%EF%BC%9F\">Q: useEffect 裡面放 async function？</a></li>\n<li><a href=\"/modern-react-with-redux/useState%E3%80%81useEffect%E3%80%81useRef%20%E4%BD%BF%E7%94%A8%E8%A3%9C%E5%85%85/#q-useeffect-%E7%9A%84-cleanup-function-%E6%80%8E%E9%BA%BC%E4%BD%BF%E7%94%A8%EF%BC%9F\">Q: useEffect 的 cleanup function 怎麼使用？</a></li>\n</ul>\n</li>\n<li><a href=\"/modern-react-with-redux/useState%E3%80%81useEffect%E3%80%81useRef%20%E4%BD%BF%E7%94%A8%E8%A3%9C%E5%85%85/#useref-%E4%BD%BF%E7%94%A8\">useRef 使用</a></li>\n</ul>","frontmatter":{"title":"CH12：useState、useEffect、useRef 使用補充","type":"coding","date":"Jul 09, 2021","tags":["React","Udemy"],"category":"Modern React with Redux","log":null,"thumbnail":null}}},"pageContext":{"slug":"/modern-react-with-redux/useState、useEffect、useRef 使用補充/","previous":{"fields":{"slug":"/modern-react-with-redux/一些元件設定與事件綁定的技巧/"},"frontmatter":{"title":"一些 React 元件設定與事件綁定的技巧","tags":["React","Udemy"],"date":"2021-06-19","category":"Modern React with Redux","mark":null,"description":"初始化 state、設 default props、處理 this 等等問題","log":"log"}},"next":null}},"staticQueryHashes":["63159454"]}